name: CI/CD (Hardened)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      auto_apply:
        description: 'Automatically apply Terraform changes'
        required: false
        default: 'false'

permissions:
  contents: read
  id-token: write

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push orders-service
        uses: docker/build-push-action@v4
        with:
          context: ./orders-service
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/orders-service:${{ github.sha }}

      - name: Build and push products-service
        uses: docker/build-push-action@v4
        with:
          context: ./products-service
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/products-service:${{ github.sha }}

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0
        with:
          cosign-release: 'v2.2.4'

      - name: Sign images with cosign (KMS or keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          IMAGE_A=${{ secrets.DOCKER_USERNAME }}/orders-service:${{ github.sha }}
          IMAGE_B=${{ secrets.DOCKER_USERNAME }}/products-service:${{ github.sha }}
          cosign version
          if [ -n "${{ secrets.COSIGN_KEY_ARN }}" ]; then
            echo "Using KMS key: ${{ secrets.COSIGN_KEY_ARN }}"
            cosign sign --key "${{ secrets.COSIGN_KEY_ARN }}" $IMAGE_A || exit 1
            cosign sign --key "${{ secrets.COSIGN_KEY_ARN }}" $IMAGE_B || exit 1
          else
            echo "No COSIGN_KEY_ARN found â€” falling back to keyless signing"
            cosign sign -y $IMAGE_A || exit 1
            cosign sign -y $IMAGE_B || exit 1
          fi

      - name: Install Trivy
        run: |
          sudo apt-get update && sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy

      - name: Trivy scan and gate orders-service image
        run: |
          IMAGE_A=${{ secrets.DOCKER_USERNAME }}/orders-service:${{ github.sha }}
          trivy image --severity CRITICAL,HIGH --exit-code 1 --no-progress $IMAGE_A || (echo "Trivy found high/critical vulnerabilities in $IMAGE_A" && exit 1)

      - name: Trivy scan and gate products-service image
        run: |
          IMAGE_B=${{ secrets.DOCKER_USERNAME }}/products-service:${{ github.sha }}
          trivy image --severity CRITICAL,HIGH --exit-code 1 --no-progress $IMAGE_B || (echo "Trivy found high/critical vulnerabilities in $IMAGE_B" && exit 1)

#      - name: SonarQube Scan (SonarCloud/Server)
#        uses: sonarsource/sonarcloud-github-action@v2.0.0
#        env:
#          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
#        with:
#          args: >-
#            -X
#            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}
#            -Dsonar.organization=${{ secrets.SONAR_ORG }}
#            -Dsonar.projectKey=${{ github.repository }}

  deploy:
    needs: build_and_push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Terraform Plan
        working-directory: infra/terraform
        run: terraform plan -var="aws_region=${{ secrets.AWS_REGION }}"

      - name: Terraform Apply (manual or automated)
        if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event.inputs.auto_apply == 'true')
        working-directory: infra/terraform
        run: terraform apply -auto-approve -var="aws_region=${{ secrets.AWS_REGION }}"

      - name: Update kubeconfig and apply ArgoCD ApplicationSet
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Update kubeconfig for the EKS cluster created by Terraform
          # Try to get cluster_name (new), fallback to cluster_id (old), then default
          CLUSTER_NAME=$(terraform -chdir=infra/terraform output -raw cluster_name 2>/dev/null || terraform -chdir=infra/terraform output -raw cluster_id 2>/dev/null || echo "devsecops-cluster")
          echo "Using Cluster Name: $CLUSTER_NAME"
          aws eks --region $AWS_REGION update-kubeconfig --name $CLUSTER_NAME
          # Apply the ApplicationSet which will create per-env ArgoCD Applications
          kubectl apply -f k8s/argo/applicationset.yaml
          # Apply Monitoring Stack
          kubectl apply -f k8s/argo/monitoring.yaml
